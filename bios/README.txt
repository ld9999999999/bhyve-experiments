BIOS emulation for bhyve
========================

I started writing this in August 2020, but due to lack of time wasn't able to be fully
engaged in getting it done right before leaving it aside. After a recent weekend,
it now boots MSDOS and FreeBSD. However it's still not complete...

The movitivation to do this was to:
* beter understand the sytem boot process
* check how well VMM works with 16-bits
* understand limitations of gcc 16-bit compilation
* implement a BIOS for bhyve
* ... hoping we'll be able to play Doom under bhyve+BIOS

Because this is running under a virtual machine, we can ignore doing things that
conform to physical hardware. For example, it uses IO port 0x100 for hypercalls
into bhyve to handle commands or process INT-13h/INT-15h requests. This is why
the ROM is really two parts: (a) the things that need to be done quickly without exiting
are in the guest's address space; and (b) the slow things like Disk IO are done
on the host.

Peter Grehan helped with questions and gave me the square wave emulation in the PIT.

-- Leon.


Limitations
-----------

>>>> This code is experimental <<<<

Only tested with MSDOS 6 (preinstalled using VMware workstation to a flat disk)
and FreeBSD disk image.

Performance issues:
* DOS launches programs slow and I haven't investigated it further. Probably
  due to its extra INT handlers to assist with upper memory copies.

Failures:
* FreeDOS
* DJGPP in MSDOS... needs to work with Protected Mode but the ROM is
  coded with Unreal mode, which is a problem

Todo
----

Either compile the C code with pure 16-bit to avoid compatibility issues between
Unreal and Protected mode. Or compile the C code in 32-bits and jump into it 


Technnicals
===========

Memory map:
-----------
  0x0000  - 0x03FF  - IVT
  0x0400  - 0x04FF  - BIOS Data Area [pre-init by bhyve]
  0x0500  - 0x7BFF  - RAM for guest OS use
  0x7C00  - 0x7DFF  - Guest boot loader sector
  0x7E00  - 0x7FFFF - RAM
  0x80000 - 0x9FFFF - Extended BIOS Area + RAM
  0xA0000 - 0xBFFFF - VGA
  0xF0000 - 0xFFFFF - BIOS ROM
    0xF0000 - 0xF4FFF  - bhyve generated ACPI, etc tables
    0xF5000 - 0xF54FF  - bhyve shared variables
    0xF5500 - 0xF5FFF  - E820 table generated by bhyve
                         24bytes per entry
                         +--------------------------------+
                         | u16 numentries |  u16 entrysz  | (header)
                         +--------------------------------+
                         | 24-byte entries ....           | (entries)
                         |                                |
                         | ...                            |

    0xF6000 - 0xF6FFF  - bhyve commands
    0xF7000 - 0XFFFFF  - BIOS ROM Code

bhyve interface.
----------------
The purpose is to reduce the number of IO exits by using a shared page
for communication between the BIOS and bhyve.  There are only two signals
sent over the IO port: commands and INT# requests.  Everything else is written
to a shared commands buffer between bhyve and the ROM.

IO port: 0x100

IO port request types (with outb):
----------------------------------
  0x02  new command in shared page
        - a new command is written to the shared page;
        - bhyve to parse it and respond in the page including error code

stored commands in shared page:
-------------------------------
struct bhyve_cmd {
    uint16 seq;           // sequence number of command
    uint16 command;       // command to issue
    uint32 result;        // result from command
    union {
       uint8  cmdargs[];  // data for the issuing the command
       uint8  data[];     // data populated from bhyve processing
    } buf;
}

bhyve_cmd.command types:
------------------------
  0x01  - setup shared data
          - argument: confirm physical address of data
          - bhyve initialization:
                BDA: fields for disks and boot device
                e820 table
  0x02  - disk params
  0x03  - disk io
  0x04  - eject ISO
  0x05  - print string - write a string at the specified cursor position
  0x06  - video commands
  0xfe  - debug print
  0xff  - power off


